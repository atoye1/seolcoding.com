/**
 * Obsidian to Hexo Markdown Converter
 *
 * PURPOSE:
 * This script converts Obsidian vault markdown files to Hexo-compatible format.
 * It processes WikiLinks, images, attachments, tags, and front matter to ensure
 * proper rendering in the Hexo static site generator.
 *
 * CONVERSIONS PERFORMED:
 * 1. WikiLinks [[Page Name]] ‚Üí [Page Name](page-name.html)
 * 2. Image WikiLinks ![[image.png]] ‚Üí ![](../images/image.png)
 * 3. Attachment links [[file.pdf]] ‚Üí [file.pdf](../images/file.pdf)
 * 4. Hashtags #tag ‚Üí Front Matter tags: [tag]
 * 5. Date format standardization
 * 6. File name normalization (spaces ‚Üí hyphens)
 *
 * USAGE:
 * node convert-obsidian-to-hexo.js --input <input_dir> --output <output_dir>
 *
 * EXAMPLE:
 * node convert-obsidian-to-hexo.js --input "50_publish/51_blog" --output "source/_posts"
 *
 * AUTHOR: Auto-generated by Claude Code
 * DATE: 2025-09-17
 */

const fs = require('fs');
const path = require('path');
const matter = require('gray-matter');

// Command line argument parsing
const args = process.argv.slice(2);
const inputDir = args[args.indexOf('--input') + 1];
const outputDir = args[args.indexOf('--output') + 1];

if (!inputDir || !outputDir) {
  console.error('Usage: node convert-obsidian-to-hexo.js --input <input_dir> --output <output_dir>');
  process.exit(1);
}

/**
 * Converts WikiLinks to standard markdown links
 * @param {string} content - The markdown content
 * @returns {string} - Converted content
 */
function convertWikiLinks(content) {
  // Convert WikiLinks with custom text: [[Page Name|Custom Text]] ‚Üí [Custom Text](page-name.html)
  content = content.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, (match, link, text) => {
    const slug = slugify(link);
    return `[${text}](../${slug}/)`;
  });

  // Convert simple WikiLinks: [[Page Name]] ‚Üí [Page Name](page-name.html)
  content = content.replace(/\[\[([^\]]+)\]\]/g, (match, link) => {
    const slug = slugify(link);
    return `[${link}](../${slug}/)`;
  });

  return content;
}

/**
 * Converts image WikiLinks to standard markdown images
 * @param {string} content - The markdown content
 * @returns {string} - Converted content
 */
function convertImageLinks(content) {
  // Convert image WikiLinks: ![[image.png]] ‚Üí ![](../images/image.png)
  content = content.replace(/!\[\[([^\]]+)\]\]/g, (match, imagePath) => {
    // Handle subfolder paths like attachments/image.png
    const cleanPath = imagePath.replace(/^attachments\//, '');
    return `![](../images/${imagePath})`;
  });

  return content;
}

/**
 * Converts attachment WikiLinks to download links
 * @param {string} content - The markdown content
 * @returns {string} - Converted content
 */
function convertAttachmentLinks(content) {
  // Convert attachment WikiLinks for non-image files: [[document.pdf]] ‚Üí [document.pdf](../images/document.pdf)
  content = content.replace(/\[\[([^\]]+\.(pdf|docx?|pptx?|xlsx?|txt|zip|rar|7z))\]\]/gi, (match, filePath) => {
    const fileName = path.basename(filePath);
    return `[${fileName}](../images/${filePath})`;
  });

  return content;
}

/**
 * Extracts hashtags from content and moves them to front matter
 * @param {string} content - The markdown content
 * @param {object} frontMatter - The front matter object
 * @returns {object} - {content, tags}
 */
function extractHashtags(content, frontMatter) {
  const tagRegex = /#([a-zA-Z0-9_Í∞Ä-Ìû£]+)/g;
  const tags = new Set(frontMatter.tags || []);
  let match;

  // Extract all hashtags
  while ((match = tagRegex.exec(content)) !== null) {
    tags.add(match[1]);
  }

  // Remove hashtags from content (optional - keep if you want them visible)
  // content = content.replace(tagRegex, '').replace(/\s+/g, ' ').trim();

  return {
    content: content,
    tags: Array.from(tags)
  };
}

/**
 * Creates or updates front matter for Hexo compatibility
 * @param {object} data - The gray-matter parsed data
 * @param {string} fileName - The original file name
 * @returns {object} - Updated front matter
 */
function processsFrontMatter(data, fileName) {
  const frontMatter = data.data || {};

  // Ensure required fields for Hexo
  if (!frontMatter.title) {
    frontMatter.title = fileName.replace(/\.md$/, '').replace(/-/g, ' ');
  }

  // Convert date formats
  if (frontMatter.created && !frontMatter.date) {
    frontMatter.date = formatDate(frontMatter.created);
    delete frontMatter.created;
  }

  if (!frontMatter.date) {
    frontMatter.date = new Date().toISOString().slice(0, 19).replace('T', ' ');
  }

  // Add default layout
  if (!frontMatter.layout) {
    frontMatter.layout = 'post';
  }

  // Enable comments by default
  if (frontMatter.comments === undefined) {
    frontMatter.comments = true;
  }

  return frontMatter;
}

/**
 * Formats date for Hexo compatibility
 * @param {string|Date} date - The input date
 * @returns {string} - Formatted date string
 */
function formatDate(date) {
  const d = new Date(date);
  if (isNaN(d.getTime())) {
    return new Date().toISOString().slice(0, 19).replace('T', ' ');
  }
  return d.toISOString().slice(0, 19).replace('T', ' ');
}

/**
 * Converts template date syntax to static timestamp
 * @param {string} content - The markdown content
 * @returns {string} - Content with converted template dates
 */
function convertTemplateDate(content) {
  const now = new Date();
  const timestamp = now.toISOString().slice(0, 19).replace('T', ' ');

  // Convert {{ date | date('YYYY-MM-DD HH:mm:ss') }} to static timestamp
  content = content.replace(/\{\{\s*date\s*\|\s*date\(['"][^'"]*['"]\)\s*\}\}/g, timestamp);

  // Convert other common date template patterns
  content = content.replace(/\{\{\s*date\s*\|\s*date\s*\}\}/g, timestamp);
  content = content.replace(/\{\{\s*now\s*\|\s*date\(['"][^'"]*['"]\)\s*\}\}/g, timestamp);

  return content;
}

/**
 * Converts string to URL-friendly slug (Korean-friendly)
 * @param {string} text - The input text
 * @returns {string} - URL-friendly slug
 */
function slugify(text) {
  return text
    .trim()
    .replace(/[\s_]+/g, '-') // Replace spaces and underscores with hyphens
    .replace(/[<>:"/\\|?*]/g, '') // Remove file system unsafe characters
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    .replace(/--+/g, '-'); // Replace multiple hyphens with single hyphen
}

/**
 * Processes a single markdown file
 * @param {string} filePath - Path to the input file
 * @param {string} outputPath - Path to the output file
 */
function processMarkdownFile(filePath, outputPath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const data = matter(content);

    console.log(`Processing: ${path.basename(filePath)}`);

    // Process front matter
    let frontMatter = processsFrontMatter(data, path.basename(filePath));

    // Convert content
    let processedContent = data.content;
    processedContent = convertWikiLinks(processedContent);
    processedContent = convertImageLinks(processedContent);
    processedContent = convertAttachmentLinks(processedContent);
    processedContent = convertTemplateDate(processedContent);

    // Extract hashtags and add to front matter
    const tagResult = extractHashtags(processedContent, frontMatter);
    processedContent = tagResult.content;
    frontMatter.tags = tagResult.tags;

    // Generate final content with front matter
    const finalContent = matter.stringify(processedContent, frontMatter);

    // Ensure output directory exists
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });

    // Write the processed file
    fs.writeFileSync(outputPath, finalContent, 'utf8');

    console.log(`‚úÖ Converted: ${path.basename(filePath)} ‚Üí ${path.basename(outputPath)}`);

  } catch (error) {
    console.error(`‚ùå Error processing ${filePath}:`, error.message);
  }
}

/**
 * Recursively processes all markdown files in a directory
 * @param {string} inputDir - Input directory path
 * @param {string} outputDir - Output directory path
 */
function processDirectory(inputDir, outputDir) {
  console.log(`üîÑ Processing directory: ${inputDir}`);
  console.log(`üìÅ Output directory: ${outputDir}`);

  if (!fs.existsSync(inputDir)) {
    console.error(`‚ùå Input directory does not exist: ${inputDir}`);
    return;
  }

  // Create output directory if it doesn't exist
  fs.mkdirSync(outputDir, { recursive: true });

  const files = fs.readdirSync(inputDir);
  let processedCount = 0;

  files.forEach(file => {
    const inputFilePath = path.join(inputDir, file);
    const stat = fs.statSync(inputFilePath);

    if (stat.isDirectory()) {
      // Skip attachments directory as files are copied separately
      if (file === 'attachments') {
        console.log(`‚è≠Ô∏è  Skipping attachments directory: ${file}`);
        return;
      }

      // Recursively process subdirectories
      const outputSubDir = path.join(outputDir, file);
      processDirectory(inputFilePath, outputSubDir);
    } else if (file.endsWith('.md')) {
      // Process markdown files
      const outputFileName = slugify(path.basename(file, '.md')) + '.md';
      const outputFilePath = path.join(outputDir, outputFileName);

      processMarkdownFile(inputFilePath, outputFilePath);
      processedCount++;
    } else {
      console.log(`‚è≠Ô∏è  Skipping non-markdown file: ${file}`);
    }
  });

  console.log(`‚úÖ Processed ${processedCount} markdown files`);
}

// Main execution
console.log('üöÄ Starting Obsidian to Hexo conversion...');
console.log(`üìÇ Input:  ${inputDir}`);
console.log(`üìÇ Output: ${outputDir}`);
console.log('---');

processDirectory(inputDir, outputDir);

console.log('---');
console.log('üéâ Conversion completed!');

// Log summary
const inputExists = fs.existsSync(inputDir);
const outputExists = fs.existsSync(outputDir);

console.log('\nüìä Summary:');
console.log(`Input directory exists: ${inputExists}`);
console.log(`Output directory created: ${outputExists}`);

if (outputExists) {
  const outputFiles = fs.readdirSync(outputDir).filter(f => f.endsWith('.md'));
  console.log(`Generated files: ${outputFiles.length}`);
  if (outputFiles.length > 0) {
    console.log('Generated files:', outputFiles.join(', '));
  }
}